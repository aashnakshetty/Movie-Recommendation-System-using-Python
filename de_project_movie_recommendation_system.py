# -*- coding: utf-8 -*-
"""DE Project: Movie Recommendation System

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Eac9ywmM6pBoiVDPyfug7aFtnKC7wxB9
"""

#Step 1: Downloading the dataset
#Unzipping the file
import zipfile
with zipfile.ZipFile('/content/ml-25m.zip', 'r') as zip_ref:
    zip_ref.extractall('/content/')

#Loading the Data:

import pandas as pd

# Load the ratings and movie data
movies = pd.read_csv('/content/ml-25m/movies.csv')

# Explore the data (e.g., check the first few rows) of ratings and movie
print("\nMovie Data:")
print(movies.head())

#Cleaning movie titles with regex
import re

def clean_title(title):
  return re.sub("[^a-zA-Z0-9 ]", "", title) # Return the cleaned title

movies["clean_title"] = movies["title"].apply(clean_title)
movies.head()

#Creating a tfidf matrix
from sklearn.feature_extraction.text import TfidfVectorizer

# Initialize TfidfVectorizer with customized stop words removal
vectorizer = TfidfVectorizer(ngram_range=(1,2))
tfidf_matrix = vectorizer.fit_transform(movies['clean_title'])

#Creating a Search Function
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np

def search(title):
  title = clean_title(title)
  query_vec = vectorizer.transform([title])
  similarity = cosine_similarity(query_vec, tfidf_matrix).flatten()
  indices = np.argpartition(similarity, -5)[-5:]
  results = movies.iloc[indices][::-1]
  return results

#Building an interactive search box
import ipywidgets as widgets
from IPython.display import display

movie_input = widgets.Text(
    value='Toy Story',
    description='Movie Title:',
    disabled=False
)
movie_list = widgets.Output()

def on_type(data):
    with movie_list:
        movie_list.clear_output()
        title = data["new"]
        if len(title) > 5:
            display(search(title))

movie_input.observe(on_type, names='value')

display(movie_input, movie_list)

#Reading the movie rating data
ratings = pd.read_csv('/content/ml-25m/ratings.csv')
ratings.head()

ratings.dtypes

#Finding users who liked the same movie
movie_id = 1
similar_users = ratings[(ratings["movieId"] == movie_id) & (ratings["rating"] > 4)]["userId"].unique()
similar_users

#Similar user recommendations
similar_user_recs = ratings[(ratings["userId"].isin(similar_users)) & (ratings["rating"] > 4)]["movieId"]
similar_user_recs

#Movies greater than (10 >=) users similar to us liked
similar_user_recs = similar_user_recs.value_counts() / len(similar_users)
similar_user_recs = similar_user_recs[similar_user_recs > .10]
print(similar_user_recs)

#Finding how much all users like movies
all_users = ratings[(ratings["movieId"].isin(similar_user_recs.index)) & (ratings["rating"] > 4)]
print(all_users)

#Percentage of user that recommend these movies
all_user_recs = all_users["movieId"].value_counts() / len(all_users["userId"].unique())
print(all_user_recs)

#Creating a recommendation score
rec_percentages = pd.concat([similar_user_recs, all_user_recs], axis=1)
rec_percentages.columns = ["similar", "all"]
print(rec_percentages)

#The score
rec_percentages["score"] = rec_percentages["similar"] / rec_percentages["all"]
rec_percentages = rec_percentages.sort_values("score", ascending=False)
print(rec_percentages)

#Taking the top 10 recommendations and merging with movies data
rec_percentages.head(10).merge(movies, left_index=True, right_on="movieId")

#Builidng a recommendation function
def find_similar_movies(movie_id):
    #Recommendations from users similar to us
    similar_users = ratings[(ratings["movieId"] == movie_id) & (ratings["rating"] > 4)]["userId"].unique()
    similar_user_recs = ratings[(ratings["userId"].isin(similar_users)) & (ratings["rating"] > 4)]["movieId"]

    #Over 10% users who recommended the movie
    similar_user_recs = similar_user_recs.value_counts() / len(similar_users)
    similar_user_recs = similar_user_recs[similar_user_recs > .10]

    #Common recommendations
    all_users = ratings[(ratings["movieId"].isin(similar_user_recs.index)) & (ratings["rating"] > 4)]
    all_user_recs = all_users["movieId"].value_counts() / len(all_users["userId"].unique())

    rec_percentages = pd.concat([similar_user_recs, all_user_recs], axis = 1)
    rec_percentages.columns = ["similar", "all"]

    rec_percentages["score"] = rec_percentages["similar"] / rec_percentages["all"]
    rec_percentages = rec_percentages.sort_values("score", ascending=False)

    return rec_percentages.head(10).merge(movies, left_index=True, right_on="movieId")[["score", "title", "genres"]]

#Creating an interactive recommendation widget
#Input Widget
movie_name_input = widgets.Text(
    value='Toy Story',
    description='Movie Title:',
    disabled=False
)

#Output Widget
recommendation_list = widgets.Output()

def on_type(data):
    with recommendation_list:
        recommendation_list.clear_output()
        title = data["new"]
        if len(title) > 5:
            results = search(title)
            movie_id = results.iloc[0]["movieId"]
            display(find_similar_movies(movie_id))

movie_name_input.observe(on_type, names='value')

display(movie_name_input, recommendation_list)